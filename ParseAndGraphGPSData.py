import matplotlib.pyplot as plt
from matplotlib import ticker
import numpy as np
import math
from math import cos, asin, sqrt, pi

#define distance given 2 coordinates
def distance(lat1, lon1, lat2, lon2):
    r = 6371 # km
    p = pi / 180
    a = 0.5 - cos((lat2-lat1)*p)/2 + cos(lat1*p) * cos(lat2*p) * (1-cos((lon2-lon1)*p))/2
    return 2 * r * asin(sqrt(a))




print("Parse and gather data from a .txt file (generated by GNSSLogger)(real data)")
print("lat            long")
#Parse and gather data from a .txt file (generated by GNSSLogger)
realdatafile = open("Real location data, 2 min log/gnss_log_2024_10_27_11_47_14.txt")
realdatalines = []
for line in realdatafile:
    if "Fix" in line and "#" not in line:
        realdatalines.append(line[:-1])
realdatafile.close()
#latitude comes first, and also is up/down, and vice versa for longitude
y_latreal_txt = []
x_longreal_txt = []
for line in realdatalines:
    y_latreal_txt.append(line.split(',')[2])
    x_longreal_txt.append(line.split(',')[3])
    print(line.split(',')[2], end=', ')#test code for verifying that it parsed correctly
    print(line.split(',')[3])
    
    

print("same as above, just for the spoofed data this time")
print("lat            long")
#same as above, just for the spoofed data this time
fakedatafile = open("Spoofed location data, 2 min log/gnss_log_2024_10_27_10_51_38.txt")
fakedatalines = []
for line in fakedatafile:
    if "Fix" in line and "#" not in line:
        fakedatalines.append(line[:-1])
fakedatafile.close()
y_latfake_txt = []
x_longfake_txt = []
for line in fakedatalines:
    y_latfake_txt.append(line.split(',')[2])
    x_longfake_txt.append(line.split(',')[3])
    print(line.split(',')[2], end=', ')#test code for verifying that it parsed correctly
    print(line.split(',')[3])



print("Parse and gather data from a .nmea file(real)")
print("Time                lat        long")
#Parse and gather data from a .nmea file
realdatafile = open("Real location data, 2 min log/gnss_log_2024_10_27_11_47_14.nmea")
realdatalines = []
for line in realdatafile:
    #it looks like brandons code must filter for $GNGGA, whilst I have to filter for $PGLOR,SPL
    #   to figure what you should parse for, ctrl-f the .nmea file, and search for the coordinate that you know it should be, 
    #   then take note of the "$..." portion at the start of the line 
    if "$PGLOR,SPL" in line:
        realdatalines.append(line[:-1])
realdatafile.close()
#latitude comes first, and also is up/down, and vice versa for longitude
timereal_nmea = []
y_latreal_nmea = []
x_longreal_nmea = []
for line in realdatalines:
    timereal_nmea.append(line.split(',')[5]) #parses for time
    y_latreal_nmea.append(line.split(',')[6]) #parses for y/lat coord
    x_longreal_nmea.append(line.split(',')[7]) #parses for y/lat coord
    print(line.split(',')[5], end=', ')#test code for verifying that it parsed correctly
    print(line.split(',')[6], end=', ') 
    print(line.split(',')[7])



print("same as above, just for the spoofed data this time\nmy .nmea files dont contain data for some reason, but if they did, this would work")
print("Time                lat        long")
#same as above, just for the spoofed data this time
#my .nmea files dont contain data for some reason, but if they did, this would work
fakedatafile = open("Spoofed location data, 2 min log/gnss_log_2024_10_27_10_51_38.nmea")
fakedatalines = []
for line in fakedatafile:
    if "$PGLOR,SPL" in line:
        fakedatalines.append(line[:-1])
fakedatafile.close()
timefake_nmea = []
y_latfake_nmea = []
x_longfake_nmea = []
for line in fakedatalines:
    timefake_nmea.append(line.split(',')[5]) 
    y_latfake_nmea.append(line.split(',')[6]) 
    x_longfake_nmea.append(line.split(',')[7]) 
    print(line.split(',')[5], end=', ')
    print(line.split(',')[6], end=', ') 
    print(line.split(',')[7])
    


print("creates a graph of everything here")
#https://www.geeksforgeeks.org/graph-plotting-in-python-set-1/ 
plt.scatter(x_longreal_txt, y_latreal_txt, label = "Real")
plt.scatter(x_longfake_txt, y_latfake_txt, label = "Spoofed")
ax = plt.gca()
ax.tick_params(axis='both', colors='white')
plt.xlabel('longitude')
plt.ylabel('latitude')
plt.title('Real Data vs Spoofed Data')
plt.legend()
plt.show()
print()


smallestList = min(len(x_longreal_txt),len(x_longfake_txt),len(y_latreal_txt),len(y_latfake_txt))
#detects anomolies based on how far away this point is from the next point. Real data from .txt
threshold = 0 #in kilometers
print("Detecting Anomolies. Threshold =", threshold, "kilometers")
#https://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula 
for x in range(0,smallestList - 1):
    y = distance(float(x_longreal_txt[x]), float(y_latreal_txt[x]), float(x_longreal_txt[x + 1]), float(y_latreal_txt[x + 1]))
    if y > threshold:
        print("Anomaly Detected. Kilometers between point this point and the next: ", y)
print()

smallestList = min(len(x_longreal_nmea),len(y_latreal_nmea),len(timereal_nmea))
#detects anomolies based on how far away this based on it's speed. Real Data from .nmea
threshold = 0 #in kilometers / second
print("Detecting Anomolies. Threshold =", threshold, "kilometers per second")
#https://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula 
for x in range(0,smallestList - 1):
    y = distance(float(x_longreal_nmea[x]), float(y_latreal_nmea[x]), float(x_longreal_nmea[x + 1]), float(y_latreal_nmea[x + 1]))
    #assume .nmea sends data every second (which mine does)
    #change/calculate 1 
    y = y / 1
    if y > threshold:
        print("Anomaly Detected. Speed: ", y)
'''
Brandons MATLAB code:

% Specify the file path
%filePath = 'gnss_log_2024_11_18_13_21_59.nmea';
filePath = 'gnss_log_2024_11_18_14_17_21.nmea';
%filePath = 'spoofed_nmea_data.txt';

% Open the file
fileID = fopen(filePath, 'r'); % 'r' read mode
rawData = textscan(fileID, '%s', 'Delimiter', '\n'); % Read all lines
fclose(fileID); % Close the file

% Extract the data
rawData = rawData{1}; % Store the lines in a cell array
disp('File loaded successfully!');

% Filter for $GNGGA sentences
gnggaData = rawData(contains(rawData, '$GNGGA')); % GPGGA for multi GNSS
disp('Extracted $GNGGA sentences.');

% Parse fields for latitude and longitude
parsedGNGGA = cellfun(@(line) split(line, ','), gnggaData, 'UniformOutput', false);

% Initialize arrays to store latitudes and longitudes
latitudes = zeros(length(parsedGNGGA), 1);
longitudes = zeros(length(parsedGNGGA), 1);

% Populate latitudes and longitudes arrays
for i = 1:length(parsedGNGGA)
    if length(parsedGNGGA{i}) < 6
        % Skip this entry if it does not have enough fields
        continue;
    end
    % Extract latitude and longitude from the correct parsed positions
    lat_str = parsedGNGGA{i}{4}; % Latitude (Degrees and Minutes)
    lon_str = parsedGNGGA{i}{6}; % Longitude (Degrees and Minutes)

    try
        % Latitude conversion (assuming the format is Degrees.Minutes)
        lat_deg = str2double(lat_str(1:2)); % Degrees part
        lat_min = str2double(lat_str(3:end)); % Minutes part
        lat = lat_deg + lat_min / 60; % Convert to decimal degrees

        % Adjust for South Latitude (if applicable)
        if contains(parsedGNGGA{i}{5}, 'S')
            lat = -lat;
        end

        % Longitude conversion (assuming the format is Degrees.Minutes)
        lon_deg = str2double(lon_str(1:3)); % Degrees part
        lon_min = str2double(lon_str(4:end)); % Minutes part
        lon = lon_deg + lon_min / 60; % Convert to decimal degrees

        % Adjust for West Longitude (if applicable)
        if contains(parsedGNGGA{i}{7}, 'W')
            lon = -lon;
        end

        % Store values in latitudes and longitudes arrays
        latitudes(i) = lat;
        longitudes(i) = lon;
    catch
        % If there's any issue with the data, skip the current iteration
        fprintf('Error processing line %d\n', i);
        continue;
    end
end

% Now apply the anomaly detection code
R = 6371; % Radius of the Earth in km
haversineDist = @(lat1, lon1, lat2, lon2) R * acos(sin(deg2rad(lat1)) * sin(deg2rad(lat2)) + cos(deg2rad(lat1)) * cos(deg2rad(lat2)) * cos(deg2rad(lon2) - deg2rad(lon1)));

threshold = 0.1; % in km (100 meters)

for i = 2:length(latitudes) % Start from the second data point
    dist = haversineDist(latitudes(i-1), longitudes(i-1), latitudes(i), longitudes(i)); % Calculate distance between consecutive points
    if dist > threshold
        fprintf('Anomaly detected between point %d and point %d. Distance: %.2f km\n', i-1, i, dist);
    end
end

% Plot the coordinates on a 2D scatter plot
figure;
scatter(longitudes, latitudes, 'filled');
title('GNSS Data Points');
'''